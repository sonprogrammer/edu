'use strict';

var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _object = require('object.assign');

var _object2 = _interopRequireDefault(_object);

var _react = require('react');

var _react2 = _interopRequireDefault(_react);

var _reactDom = require('react-dom');

var _reactDom2 = _interopRequireDefault(_reactDom);

var _server = require('react-dom/server');

var _server2 = _interopRequireDefault(_server);

var _shallow = require('react-test-renderer/shallow');

var _shallow2 = _interopRequireDefault(_shallow);

var _testUtils = require('react-dom/test-utils');

var _testUtils2 = _interopRequireDefault(_testUtils);

var _checkPropTypes2 = require('prop-types/checkPropTypes');

var _checkPropTypes3 = _interopRequireDefault(_checkPropTypes2);

var _reactIs = require('react-is');

var _enzyme = require('enzyme');

var _Utils = require('enzyme/build/Utils');

var _enzymeAdapterUtils = require('enzyme-adapter-utils');

var _reflection = require('react-reconciler/reflection');

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }

function _toConsumableArray(arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) { arr2[i] = arr[i]; } return arr2; } else { return Array.from(arr); } }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; } /* eslint no-use-before-define: 0 */

// eslint-disable-next-line import/no-unresolved

// eslint-disable-next-line import/no-unresolved

// eslint-disable-next-line import/no-unresolved


var HostRoot = 3;
var ClassComponent = 2;
var FragmentType = 10;
var FunctionalComponent = 1;
var HostPortal = 4;
var HostComponent = 5;
var HostText = 6;
var Mode = 11;
var ContextConsumerType = 12;
var ContextProviderType = 13;
var ForwardRefType = 14;

function nodeAndSiblingsArray(nodeWithSibling) {
  var array = [];
  var node = nodeWithSibling;
  while (node != null) {
    array.push(node);
    node = node.sibling;
  }
  return array;
}

function flatten(arr) {
  var result = [];
  var stack = [{ i: 0, array: arr }];
  while (stack.length) {
    var n = stack.pop();
    while (n.i < n.array.length) {
      var el = n.array[n.i];
      n.i += 1;
      if (Array.isArray(el)) {
        stack.push(n);
        stack.push({ i: 0, array: el });
        break;
      }
      result.push(el);
    }
  }
  return result;
}

function nodeTypeFromType(type) {
  if (type === _reactIs.Portal) {
    return 'portal';
  }

  return (0, _enzymeAdapterUtils.nodeTypeFromType)(type);
}

function elementToTree(el) {
  if (!(0, _reactIs.isPortal)(el)) {
    return (0, _enzymeAdapterUtils.elementToTree)(el, elementToTree);
  }

  var children = el.children,
      containerInfo = el.containerInfo;

  var props = { children: children, containerInfo: containerInfo };

  return {
    nodeType: 'portal',
    type: _reactIs.Portal,
    props: props,
    key: (0, _enzymeAdapterUtils.ensureKeyOrUndefined)(el.key),
    ref: el.ref || null,
    instance: null,
    rendered: elementToTree(el.children)
  };
}

function _toTree(vnode) {
  if (vnode == null) {
    return null;
  }
  // TODO(lmr): I'm not really sure I understand whether or not this is what
  // i should be doing, or if this is a hack for something i'm doing wrong
  // somewhere else. Should talk to sebastian about this perhaps
  var node = (0, _reflection.findCurrentFiberUsingSlowPath)(vnode);
  switch (node.tag) {
    case HostRoot:
      // 3
      return childrenToTree(node.child);
    case HostPortal:
      {
        // 4
        var containerInfo = node.stateNode.containerInfo,
            children = node.memoizedProps;

        var props = { containerInfo: containerInfo, children: children };
        return {
          nodeType: 'portal',
          type: _reactIs.Portal,
          props: props,
          key: (0, _enzymeAdapterUtils.ensureKeyOrUndefined)(node.key),
          ref: node.ref,
          instance: null,
          rendered: childrenToTree(node.child)
        };
      }
    case ClassComponent:
      return {
        nodeType: 'class',
        type: node.type,
        props: (0, _object2['default'])({}, node.memoizedProps),
        key: (0, _enzymeAdapterUtils.ensureKeyOrUndefined)(node.key),
        ref: node.ref,
        instance: node.stateNode,
        rendered: childrenToTree(node.child)
      };
    case FunctionalComponent:
      // 1
      return {
        nodeType: 'function',
        type: node.type,
        props: (0, _object2['default'])({}, node.memoizedProps),
        key: (0, _enzymeAdapterUtils.ensureKeyOrUndefined)(node.key),
        ref: node.ref,
        instance: null,
        rendered: childrenToTree(node.child)
      };
    case HostComponent:
      {
        // 5
        var renderedNodes = flatten(nodeAndSiblingsArray(node.child).map(_toTree));
        if (renderedNodes.length === 0) {
          renderedNodes = [node.memoizedProps.children];
        }
        return {
          nodeType: 'host',
          type: node.type,
          props: (0, _object2['default'])({}, node.memoizedProps),
          key: (0, _enzymeAdapterUtils.ensureKeyOrUndefined)(node.key),
          ref: node.ref,
          instance: node.stateNode,
          rendered: renderedNodes
        };
      }
    case HostText:
      // 6
      return node.memoizedProps;
    case FragmentType: // 10
    case Mode: // 11
    case ContextProviderType: // 13
    case ContextConsumerType:
      // 12
      return childrenToTree(node.child);
    case ForwardRefType:
      {
        return {
          nodeType: 'function',
          type: node.type,
          props: (0, _object2['default'])({}, node.pendingProps),
          key: (0, _enzymeAdapterUtils.ensureKeyOrUndefined)(node.key),
          ref: node.ref,
          instance: null,
          rendered: childrenToTree(node.child)
        };
      }
    default:
      throw new Error('Enzyme Internal Error: unknown node with tag ' + String(node.tag));
  }
}

function childrenToTree(node) {
  if (!node) {
    return null;
  }
  var children = nodeAndSiblingsArray(node);
  if (children.length === 0) {
    return null;
  }
  if (children.length === 1) {
    return _toTree(children[0]);
  }
  return flatten(children.map(_toTree));
}

function _nodeToHostNode(_node) {
  // NOTE(lmr): node could be a function component
  // which wont have an instance prop, but we can get the
  // host node associated with its return value at that point.
  // Although this breaks down if the return value is an array,
  // as is possible with React 16.
  var node = _node;
  while (node && !Array.isArray(node) && node.instance === null) {
    node = node.rendered;
  }
  // if the SFC returned null effectively, there is no host node.
  if (!node) {
    return null;
  }

  var mapper = function mapper(item) {
    if (item && item.instance) return _reactDom2['default'].findDOMNode(item.instance);
    return null;
  };
  if (Array.isArray(node)) {
    return node.map(mapper);
  }
  if (Array.isArray(node.rendered) && node.nodeType === 'class') {
    return node.rendered.map(mapper);
  }
  return mapper(node);
}

function getProviderDefaultValue(Provider) {
  // React stores references to the Provider's defaultValue differently across versions.
  if ('_defaultValue' in Provider._context) {
    return Provider._context._defaultValue;
  }
  throw new Error('Enzyme Internal Error: can’t figure out how to get Provider’s default value');
}

function makeFakeElement(type) {
  return { $$typeof: _reactIs.Element, type: type };
}

var eventOptions = { animation: true };

var ReactSixteenThreeAdapter = function (_EnzymeAdapter) {
  _inherits(ReactSixteenThreeAdapter, _EnzymeAdapter);

  function ReactSixteenThreeAdapter() {
    _classCallCheck(this, ReactSixteenThreeAdapter);

    var _this = _possibleConstructorReturn(this, (ReactSixteenThreeAdapter.__proto__ || Object.getPrototypeOf(ReactSixteenThreeAdapter)).call(this));

    var lifecycles = _this.options.lifecycles;

    _this.options = (0, _object2['default'])({}, _this.options, {
      enableComponentDidUpdateOnSetState: true, // TODO: remove, semver-major
      legacyContextMode: 'parent',
      lifecycles: (0, _object2['default'])({}, lifecycles, {
        componentDidUpdate: {
          onSetState: true
        },
        getDerivedStateFromProps: {
          hasShouldComponentUpdateBug: true
        },
        getSnapshotBeforeUpdate: true,
        setState: {
          skipsComponentDidUpdateOnNullish: true
        },
        getChildContext: {
          calledByRenderer: false
        }
      })
    });
    return _this;
  }

  _createClass(ReactSixteenThreeAdapter, [{
    key: 'createMountRenderer',
    value: function () {
      function createMountRenderer(options) {
        (0, _enzymeAdapterUtils.assertDomAvailable)('mount');
        var attachTo = options.attachTo,
            hydrateIn = options.hydrateIn,
            wrappingComponentProps = options.wrappingComponentProps;

        var domNode = hydrateIn || attachTo || global.document.createElement('div');
        var instance = null;
        var adapter = this;
        return {
          render: function () {
            function render(el, context, callback) {
              if (instance === null) {
                var type = el.type,
                    props = el.props,
                    ref = el.ref;

                var wrapperProps = (0, _object2['default'])({
                  Component: type,
                  props: props,
                  wrappingComponentProps: wrappingComponentProps,
                  context: context
                }, ref && { ref: ref });
                var ReactWrapperComponent = (0, _enzymeAdapterUtils.createMountWrapper)(el, (0, _object2['default'])({}, options, { adapter: adapter }));
                var wrappedEl = _react2['default'].createElement(ReactWrapperComponent, wrapperProps);
                instance = hydrateIn ? _reactDom2['default'].hydrate(wrappedEl, domNode) : _reactDom2['default'].render(wrappedEl, domNode);
                if (typeof callback === 'function') {
                  callback();
                }
              } else {
                instance.setChildProps(el.props, context, callback);
              }
            }

            return render;
          }(),
          unmount: function () {
            function unmount() {
              _reactDom2['default'].unmountComponentAtNode(domNode);
              instance = null;
            }

            return unmount;
          }(),
          getNode: function () {
            function getNode() {
              if (!instance) {
                return null;
              }
              return (0, _enzymeAdapterUtils.getNodeFromRootFinder)(adapter.isCustomComponent, _toTree(instance._reactInternalFiber), options);
            }

            return getNode;
          }(),
          simulateError: function () {
            function simulateError(nodeHierarchy, rootNode, error) {
              var _ref = nodeHierarchy.find(function (x) {
                return x.instance && x.instance.componentDidCatch;
              }) || {},
                  catchingInstance = _ref.instance;

              (0, _enzymeAdapterUtils.simulateError)(error, catchingInstance, rootNode, nodeHierarchy, nodeTypeFromType, adapter.displayNameOfNode);
            }

            return simulateError;
          }(),
          simulateEvent: function () {
            function simulateEvent(node, event, mock) {
              var mappedEvent = (0, _enzymeAdapterUtils.mapNativeEventNames)(event, eventOptions);
              var eventFn = _testUtils2['default'].Simulate[mappedEvent];
              if (!eventFn) {
                throw new TypeError('ReactWrapper::simulate() event \'' + String(event) + '\' does not exist');
              }
              // eslint-disable-next-line react/no-find-dom-node
              eventFn(adapter.nodeToHostNode(node), mock);
            }

            return simulateEvent;
          }(),
          batchedUpdates: function () {
            function batchedUpdates(fn) {
              return fn();
              // return ReactDOM.unstable_batchedUpdates(fn);
            }

            return batchedUpdates;
          }(),
          getWrappingComponentRenderer: function () {
            function getWrappingComponentRenderer() {
              return (0, _object2['default'])({}, this, (0, _enzymeAdapterUtils.getWrappingComponentMountRenderer)({
                toTree: function () {
                  function toTree(inst) {
                    return _toTree(inst._reactInternalFiber);
                  }

                  return toTree;
                }(),
                getMountWrapperInstance: function () {
                  function getMountWrapperInstance() {
                    return instance;
                  }

                  return getMountWrapperInstance;
                }()
              }));
            }

            return getWrappingComponentRenderer;
          }()
        };
      }

      return createMountRenderer;
    }()
  }, {
    key: 'createShallowRenderer',
    value: function () {
      function createShallowRenderer() /* options */{
        var adapter = this;
        var renderer = new _shallow2['default']();
        var isDOM = false;
        var cachedNode = null;
        return {
          render: function () {
            function render(el, context) {
              var _ref2 = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {},
                  _ref2$providerValues = _ref2.providerValues,
                  providerValues = _ref2$providerValues === undefined ? new Map() : _ref2$providerValues;

              cachedNode = el;
              /* eslint consistent-return: 0 */
              if (typeof el.type === 'string') {
                isDOM = true;
              } else if ((0, _reactIs.isContextProvider)(el)) {
                providerValues.set(el.type, el.props.value);
                var MockProvider = (0, _object2['default'])(function (props) {
                  return props.children;
                }, el.type);
                return (0, _enzymeAdapterUtils.withSetStateAllowed)(function () {
                  return renderer.render((0, _object2['default'])({}, el, { type: MockProvider }));
                });
              } else if ((0, _reactIs.isContextConsumer)(el)) {
                var Provider = adapter.getProviderFromConsumer(el.type);
                var value = providerValues.has(Provider) ? providerValues.get(Provider) : getProviderDefaultValue(Provider);
                var MockConsumer = (0, _object2['default'])(function (props) {
                  return props.children(value);
                }, el.type);
                return (0, _enzymeAdapterUtils.withSetStateAllowed)(function () {
                  return renderer.render((0, _object2['default'])({}, el, { type: MockConsumer }));
                });
              } else {
                isDOM = false;
                var Component = el.type;


                var isStateful = Component.prototype && (Component.prototype.isReactComponent || Array.isArray(Component.__reactAutoBindPairs) // fallback for createClass components
                );

                if (!isStateful && typeof Component === 'function') {
                  var wrappedEl = (0, _object2['default'])(function () {
                    return Component.apply(undefined, arguments);
                  }, // eslint-disable-line new-cap
                  Component);
                  return (0, _enzymeAdapterUtils.withSetStateAllowed)(function () {
                    return renderer.render((0, _object2['default'])({}, el, { type: wrappedEl }), context);
                  });
                }
                return (0, _enzymeAdapterUtils.withSetStateAllowed)(function () {
                  return renderer.render(el, context);
                });
              }
            }

            return render;
          }(),
          unmount: function () {
            function unmount() {
              renderer.unmount();
            }

            return unmount;
          }(),
          getNode: function () {
            function getNode() {
              if (isDOM) {
                return elementToTree(cachedNode);
              }
              var output = renderer.getRenderOutput();
              return {
                nodeType: nodeTypeFromType(cachedNode.type),
                type: cachedNode.type,
                props: cachedNode.props,
                key: (0, _enzymeAdapterUtils.ensureKeyOrUndefined)(cachedNode.key),
                ref: cachedNode.ref,
                instance: renderer._instance,
                rendered: Array.isArray(output) ? flatten(output).map(function (el) {
                  return elementToTree(el);
                }) : elementToTree(output)
              };
            }

            return getNode;
          }(),
          simulateError: function () {
            function simulateError(nodeHierarchy, rootNode, error) {
              (0, _enzymeAdapterUtils.simulateError)(error, renderer._instance, cachedNode, nodeHierarchy.concat(cachedNode), nodeTypeFromType, adapter.displayNameOfNode);
            }

            return simulateError;
          }(),
          simulateEvent: function () {
            function simulateEvent(node, event) {
              for (var _len = arguments.length, args = Array(_len > 2 ? _len - 2 : 0), _key = 2; _key < _len; _key++) {
                args[_key - 2] = arguments[_key];
              }

              var handler = node.props[(0, _enzymeAdapterUtils.propFromEvent)(event, eventOptions)];
              if (handler) {
                (0, _enzymeAdapterUtils.withSetStateAllowed)(function () {
                  // TODO(lmr): create/use synthetic events
                  // TODO(lmr): emulate React's event propagation
                  // ReactDOM.unstable_batchedUpdates(() => {
                  handler.apply(undefined, _toConsumableArray(args));
                  // });
                });
              }
            }

            return simulateEvent;
          }(),
          batchedUpdates: function () {
            function batchedUpdates(fn) {
              return fn();
              // return ReactDOM.unstable_batchedUpdates(fn);
            }

            return batchedUpdates;
          }(),
          checkPropTypes: function () {
            function checkPropTypes(typeSpecs, values, location, hierarchy) {
              return (0, _checkPropTypes3['default'])(typeSpecs, values, location, (0, _enzymeAdapterUtils.displayNameOfNode)(cachedNode), function () {
                return (0, _enzymeAdapterUtils.getComponentStack)(hierarchy.concat([cachedNode]));
              });
            }

            return checkPropTypes;
          }()
        };
      }

      return createShallowRenderer;
    }()
  }, {
    key: 'createStringRenderer',
    value: function () {
      function createStringRenderer(options) {
        return {
          render: function () {
            function render(el, context) {
              if (options.context && (el.type.contextTypes || options.childContextTypes)) {
                var childContextTypes = (0, _object2['default'])({}, el.type.contextTypes || {}, options.childContextTypes);
                var ContextWrapper = (0, _enzymeAdapterUtils.createRenderWrapper)(el, context, childContextTypes);
                return _server2['default'].renderToStaticMarkup(_react2['default'].createElement(ContextWrapper));
              }
              return _server2['default'].renderToStaticMarkup(el);
            }

            return render;
          }()
        };
      }

      return createStringRenderer;
    }()

    // Provided a bag of options, return an `EnzymeRenderer`. Some options can be implementation
    // specific, like `attach` etc. for React, but not part of this interface explicitly.
    // eslint-disable-next-line class-methods-use-this, no-unused-vars

  }, {
    key: 'createRenderer',
    value: function () {
      function createRenderer(options) {
        switch (options.mode) {
          case _enzyme.EnzymeAdapter.MODES.MOUNT:
            return this.createMountRenderer(options);
          case _enzyme.EnzymeAdapter.MODES.SHALLOW:
            return this.createShallowRenderer(options);
          case _enzyme.EnzymeAdapter.MODES.STRING:
            return this.createStringRenderer(options);
          default:
            throw new Error('Enzyme Internal Error: Unrecognized mode: ' + String(options.mode));
        }
      }

      return createRenderer;
    }()
  }, {
    key: 'wrap',
    value: function () {
      function wrap(element) {
        return (0, _enzymeAdapterUtils.wrap)(element);
      }

      return wrap;
    }()

    // converts an RSTNode to the corresponding JSX Pragma Element. This will be needed
    // in order to implement the `Wrapper.mount()` and `Wrapper.shallow()` methods, but should
    // be pretty straightforward for people to implement.
    // eslint-disable-next-line class-methods-use-this, no-unused-vars

  }, {
    key: 'nodeToElement',
    value: function () {
      function nodeToElement(node) {
        if (!node || (typeof node === 'undefined' ? 'undefined' : _typeof(node)) !== 'object') return null;
        return _react2['default'].createElement(node.type, (0, _enzymeAdapterUtils.propsWithKeysAndRef)(node));
      }

      return nodeToElement;
    }()
  }, {
    key: 'elementToNode',
    value: function () {
      function elementToNode(element) {
        return elementToTree(element);
      }

      return elementToNode;
    }()
  }, {
    key: 'nodeToHostNode',
    value: function () {
      function nodeToHostNode(node) {
        var supportsArray = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;

        var nodes = _nodeToHostNode(node);
        if (Array.isArray(nodes) && !supportsArray) {
          return nodes[0];
        }
        return nodes;
      }

      return nodeToHostNode;
    }()
  }, {
    key: 'displayNameOfNode',
    value: function () {
      function displayNameOfNode(node) {
        if (!node) return null;
        var type = node.type,
            $$typeof = node.$$typeof;


        var nodeType = type || $$typeof;

        // newer node types may be undefined, so only test if the nodeType exists
        if (nodeType) {
          switch (nodeType) {
            case _reactIs.AsyncMode || NaN:
              return 'AsyncMode';
            case _reactIs.Fragment || NaN:
              return 'Fragment';
            case _reactIs.StrictMode || NaN:
              return 'StrictMode';
            case _reactIs.Portal || NaN:
              return 'Portal';
            default:
          }
        }

        var $$typeofType = type && type.$$typeof;

        switch ($$typeofType) {
          case _reactIs.ContextConsumer || NaN:
            return 'ContextConsumer';
          case _reactIs.ContextProvider || NaN:
            return 'ContextProvider';
          case _reactIs.ForwardRef || NaN:
            {
              if (type.displayName) {
                return type.displayName;
              }
              var name = (0, _enzymeAdapterUtils.displayNameOfNode)({ type: type.render });
              return name ? 'ForwardRef(' + String(name) + ')' : 'ForwardRef';
            }
          default:
            return (0, _enzymeAdapterUtils.displayNameOfNode)(node);
        }
      }

      return displayNameOfNode;
    }()
  }, {
    key: 'isValidElement',
    value: function () {
      function isValidElement(element) {
        return (0, _reactIs.isElement)(element);
      }

      return isValidElement;
    }()
  }, {
    key: 'isValidElementType',
    value: function () {
      function isValidElementType(object) {
        return !!object && (0, _reactIs.isValidElementType)(object);
      }

      return isValidElementType;
    }()
  }, {
    key: 'isFragment',
    value: function () {
      function isFragment(fragment) {
        return (0, _Utils.typeOfNode)(fragment) === _reactIs.Fragment;
      }

      return isFragment;
    }()
  }, {
    key: 'isCustomComponent',
    value: function () {
      function isCustomComponent(type) {
        var fakeElement = makeFakeElement(type);
        return !!type && (typeof type === 'function' || (0, _reactIs.isForwardRef)(fakeElement) || (0, _reactIs.isContextProvider)(fakeElement) || (0, _reactIs.isContextConsumer)(fakeElement));
      }

      return isCustomComponent;
    }()
  }, {
    key: 'isContextConsumer',
    value: function () {
      function isContextConsumer(type) {
        return !!type && (0, _reactIs.isContextConsumer)(makeFakeElement(type));
      }

      return isContextConsumer;
    }()
  }, {
    key: 'isCustomComponentElement',
    value: function () {
      function isCustomComponentElement(inst) {
        if (!inst || !this.isValidElement(inst)) {
          return false;
        }
        return this.isCustomComponent(inst.type);
      }

      return isCustomComponentElement;
    }()
  }, {
    key: 'getProviderFromConsumer',
    value: function () {
      function getProviderFromConsumer(Consumer) {
        var _ref3 = Consumer || {},
            Provider = _ref3.Provider;

        if (Provider) {
          return Provider;
        }
        throw new Error('Enzyme Internal Error: can’t figure out how to get Provider from Consumer');
      }

      return getProviderFromConsumer;
    }()
  }, {
    key: 'createElement',
    value: function () {
      function createElement() {
        return _react2['default'].createElement.apply(_react2['default'], arguments);
      }

      return createElement;
    }()
  }, {
    key: 'wrapWithWrappingComponent',
    value: function () {
      function wrapWithWrappingComponent(node, options) {
        return {
          RootFinder: _enzymeAdapterUtils.RootFinder,
          node: (0, _enzymeAdapterUtils.wrapWithWrappingComponent)(_react2['default'].createElement, node, options)
        };
      }

      return wrapWithWrappingComponent;
    }()
  }]);

  return ReactSixteenThreeAdapter;
}(_enzyme.EnzymeAdapter);

module.exports = ReactSixteenThreeAdapter;
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uL3NyYy9SZWFjdFNpeHRlZW5UaHJlZUFkYXB0ZXIuanMiXSwibmFtZXMiOlsiSG9zdFJvb3QiLCJDbGFzc0NvbXBvbmVudCIsIkZyYWdtZW50VHlwZSIsIkZ1bmN0aW9uYWxDb21wb25lbnQiLCJIb3N0UG9ydGFsIiwiSG9zdENvbXBvbmVudCIsIkhvc3RUZXh0IiwiTW9kZSIsIkNvbnRleHRDb25zdW1lclR5cGUiLCJDb250ZXh0UHJvdmlkZXJUeXBlIiwiRm9yd2FyZFJlZlR5cGUiLCJub2RlQW5kU2libGluZ3NBcnJheSIsIm5vZGVXaXRoU2libGluZyIsImFycmF5Iiwibm9kZSIsInB1c2giLCJzaWJsaW5nIiwiZmxhdHRlbiIsImFyciIsInJlc3VsdCIsInN0YWNrIiwiaSIsImxlbmd0aCIsIm4iLCJwb3AiLCJlbCIsIkFycmF5IiwiaXNBcnJheSIsIm5vZGVUeXBlRnJvbVR5cGUiLCJ0eXBlIiwiUG9ydGFsIiwiZWxlbWVudFRvVHJlZSIsImNoaWxkcmVuIiwiY29udGFpbmVySW5mbyIsInByb3BzIiwibm9kZVR5cGUiLCJrZXkiLCJyZWYiLCJpbnN0YW5jZSIsInJlbmRlcmVkIiwidG9UcmVlIiwidm5vZGUiLCJ0YWciLCJjaGlsZHJlblRvVHJlZSIsImNoaWxkIiwic3RhdGVOb2RlIiwibWVtb2l6ZWRQcm9wcyIsInJlbmRlcmVkTm9kZXMiLCJtYXAiLCJwZW5kaW5nUHJvcHMiLCJFcnJvciIsIm5vZGVUb0hvc3ROb2RlIiwiX25vZGUiLCJtYXBwZXIiLCJpdGVtIiwiUmVhY3RET00iLCJmaW5kRE9NTm9kZSIsImdldFByb3ZpZGVyRGVmYXVsdFZhbHVlIiwiUHJvdmlkZXIiLCJfY29udGV4dCIsIl9kZWZhdWx0VmFsdWUiLCJtYWtlRmFrZUVsZW1lbnQiLCIkJHR5cGVvZiIsIkVsZW1lbnQiLCJldmVudE9wdGlvbnMiLCJhbmltYXRpb24iLCJSZWFjdFNpeHRlZW5UaHJlZUFkYXB0ZXIiLCJsaWZlY3ljbGVzIiwib3B0aW9ucyIsImVuYWJsZUNvbXBvbmVudERpZFVwZGF0ZU9uU2V0U3RhdGUiLCJsZWdhY3lDb250ZXh0TW9kZSIsImNvbXBvbmVudERpZFVwZGF0ZSIsIm9uU2V0U3RhdGUiLCJnZXREZXJpdmVkU3RhdGVGcm9tUHJvcHMiLCJoYXNTaG91bGRDb21wb25lbnRVcGRhdGVCdWciLCJnZXRTbmFwc2hvdEJlZm9yZVVwZGF0ZSIsInNldFN0YXRlIiwic2tpcHNDb21wb25lbnREaWRVcGRhdGVPbk51bGxpc2giLCJnZXRDaGlsZENvbnRleHQiLCJjYWxsZWRCeVJlbmRlcmVyIiwiYXR0YWNoVG8iLCJoeWRyYXRlSW4iLCJ3cmFwcGluZ0NvbXBvbmVudFByb3BzIiwiZG9tTm9kZSIsImdsb2JhbCIsImRvY3VtZW50IiwiY3JlYXRlRWxlbWVudCIsImFkYXB0ZXIiLCJyZW5kZXIiLCJjb250ZXh0IiwiY2FsbGJhY2siLCJ3cmFwcGVyUHJvcHMiLCJDb21wb25lbnQiLCJSZWFjdFdyYXBwZXJDb21wb25lbnQiLCJ3cmFwcGVkRWwiLCJSZWFjdCIsImh5ZHJhdGUiLCJzZXRDaGlsZFByb3BzIiwidW5tb3VudCIsInVubW91bnRDb21wb25lbnRBdE5vZGUiLCJnZXROb2RlIiwiaXNDdXN0b21Db21wb25lbnQiLCJfcmVhY3RJbnRlcm5hbEZpYmVyIiwic2ltdWxhdGVFcnJvciIsIm5vZGVIaWVyYXJjaHkiLCJyb290Tm9kZSIsImVycm9yIiwiZmluZCIsIngiLCJjb21wb25lbnREaWRDYXRjaCIsImNhdGNoaW5nSW5zdGFuY2UiLCJkaXNwbGF5TmFtZU9mTm9kZSIsInNpbXVsYXRlRXZlbnQiLCJldmVudCIsIm1vY2siLCJtYXBwZWRFdmVudCIsImV2ZW50Rm4iLCJUZXN0VXRpbHMiLCJTaW11bGF0ZSIsIlR5cGVFcnJvciIsImJhdGNoZWRVcGRhdGVzIiwiZm4iLCJnZXRXcmFwcGluZ0NvbXBvbmVudFJlbmRlcmVyIiwiaW5zdCIsImdldE1vdW50V3JhcHBlckluc3RhbmNlIiwicmVuZGVyZXIiLCJTaGFsbG93UmVuZGVyZXIiLCJpc0RPTSIsImNhY2hlZE5vZGUiLCJwcm92aWRlclZhbHVlcyIsIk1hcCIsInNldCIsInZhbHVlIiwiTW9ja1Byb3ZpZGVyIiwiZ2V0UHJvdmlkZXJGcm9tQ29uc3VtZXIiLCJoYXMiLCJnZXQiLCJNb2NrQ29uc3VtZXIiLCJpc1N0YXRlZnVsIiwicHJvdG90eXBlIiwiaXNSZWFjdENvbXBvbmVudCIsIl9fcmVhY3RBdXRvQmluZFBhaXJzIiwib3V0cHV0IiwiZ2V0UmVuZGVyT3V0cHV0IiwiX2luc3RhbmNlIiwiY29uY2F0IiwiYXJncyIsImhhbmRsZXIiLCJjaGVja1Byb3BUeXBlcyIsInR5cGVTcGVjcyIsInZhbHVlcyIsImxvY2F0aW9uIiwiaGllcmFyY2h5IiwiY29udGV4dFR5cGVzIiwiY2hpbGRDb250ZXh0VHlwZXMiLCJDb250ZXh0V3JhcHBlciIsIlJlYWN0RE9NU2VydmVyIiwicmVuZGVyVG9TdGF0aWNNYXJrdXAiLCJtb2RlIiwiRW56eW1lQWRhcHRlciIsIk1PREVTIiwiTU9VTlQiLCJjcmVhdGVNb3VudFJlbmRlcmVyIiwiU0hBTExPVyIsImNyZWF0ZVNoYWxsb3dSZW5kZXJlciIsIlNUUklORyIsImNyZWF0ZVN0cmluZ1JlbmRlcmVyIiwiZWxlbWVudCIsInN1cHBvcnRzQXJyYXkiLCJub2RlcyIsIkFzeW5jTW9kZSIsIk5hTiIsIkZyYWdtZW50IiwiU3RyaWN0TW9kZSIsIiQkdHlwZW9mVHlwZSIsIkNvbnRleHRDb25zdW1lciIsIkNvbnRleHRQcm92aWRlciIsIkZvcndhcmRSZWYiLCJkaXNwbGF5TmFtZSIsIm5hbWUiLCJvYmplY3QiLCJmcmFnbWVudCIsImZha2VFbGVtZW50IiwiaXNWYWxpZEVsZW1lbnQiLCJDb25zdW1lciIsIlJvb3RGaW5kZXIiLCJtb2R1bGUiLCJleHBvcnRzIl0sIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7O0FBQ0E7Ozs7QUFDQTs7OztBQUVBOzs7O0FBRUE7Ozs7QUFFQTs7OztBQUNBOzs7O0FBQ0E7O0FBZ0JBOztBQUNBOztBQUNBOztBQW9CQTs7Ozs7Ozs7Ozsr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TVQsYUFBaEMsRUFBK0N4RSxJQUEvQyxFQUFxRHNELE9BQXJEO0FBRkQsU0FBUDtBQUlEOzs7Ozs7O0VBaFdvQzJGLHFCOztBQW1XdkMyQixPQUFPQyxPQUFQLEdBQWlCekgsd0JBQWpCIiwiZmlsZSI6IlJlYWN0U2l4dGVlblRocmVlQWRhcHRlci5qcyIsInNvdXJjZXNDb250ZW50IjpbIi8qIGVzbGludCBuby11c2UtYmVmb3JlLWRlZmluZTogMCAqL1xuaW1wb3J0IFJlYWN0IGZyb20gJ3JlYWN0JztcbmltcG9ydCBSZWFjdERPTSBmcm9tICdyZWFjdC1kb20nO1xuLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIGltcG9ydC9uby11bnJlc29sdmVkXG5pbXBvcnQgUmVhY3RET01TZXJ2ZXIgZnJvbSAncmVhY3QtZG9tL3NlcnZlcic7XG4vLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgaW1wb3J0L25vLXVucmVzb2x2ZWRcbmltcG9ydCBTaGFsbG93UmVuZGVyZXIgZnJvbSAncmVhY3QtdGVzdC1yZW5kZXJlci9zaGFsbG93Jztcbi8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBpbXBvcnQvbm8tdW5yZXNvbHZlZFxuaW1wb3J0IFRlc3RVdGlscyBmcm9tICdyZWFjdC1kb20vdGVzdC11dGlscyc7XG5pbXBvcnQgY2hlY2tQcm9wVHlwZXMgZnJvbSAncHJvcC10eXBlcy9jaGVja1Byb3BUeXBlcyc7XG5pbXBvcnQge1xuICBBc3luY01vZGUsXG4gIENvbnRleHRDb25zdW1lcixcbiAgQ29udGV4dFByb3ZpZGVyLFxuICBFbGVtZW50LFxuICBGb3J3YXJkUmVmLFxuICBGcmFnbWVudCxcbiAgaXNDb250ZXh0Q29uc3VtZXIsXG4gIGlzQ29udGV4dFByb3ZpZGVyLFxuICBpc0VsZW1lbnQsXG4gIGlzRm9yd2FyZFJlZixcbiAgaXNQb3J0YWwsXG4gIGlzVmFsaWRFbGVtZW50VHlwZSxcbiAgUG9ydGFsLFxuICBTdHJpY3RNb2RlLFxufSBmcm9tICdyZWFjdC1pcyc7XG5pbXBvcnQgeyBFbnp5bWVBZGFwdGVyIH0gZnJvbSAnZW56eW1lJztcbmltcG9ydCB7IHR5cGVPZk5vZGUgfSBmcm9tICdlbnp5bWUvYnVpbGQvVXRpbHMnO1xuaW1wb3J0IHtcbiAgZGlzcGxheU5hbWVPZk5vZGUsXG4gIGVsZW1lbnRUb1RyZWUgYXMgdXRpbEVsZW1lbnRUb1RyZWUsXG4gIG5vZGVUeXBlRnJvbVR5cGUgYXMgdXRpbE5vZGVUeXBlRnJvbVR5cGUsXG4gIG1hcE5hdGl2ZUV2ZW50TmFtZXMsXG4gIHByb3BGcm9tRXZlbnQsXG4gIGFzc2VydERvbUF2YWlsYWJsZSxcbiAgd2l0aFNldFN0YXRlQWxsb3dlZCxcbiAgY3JlYXRlUmVuZGVyV3JhcHBlcixcbiAgY3JlYXRlTW91bnRXcmFwcGVyLFxuICBwcm9wc1dpdGhLZXlzQW5kUmVmLFxuICBlbnN1cmVLZXlPclVuZGVmaW5lZCxcbiAgc2ltdWxhdGVFcnJvcixcbiAgd3JhcCxcbiAgZ2V0Q29tcG9uZW50U3RhY2ssXG4gIFJvb3RGaW5kZXIsXG4gIGdldE5vZGVGcm9tUm9vdEZpbmRlcixcbiAgd3JhcFdpdGhXcmFwcGluZ0NvbXBvbmVudCxcbiAgZ2V0V3JhcHBpbmdDb21wb25lbnRNb3VudFJlbmRlcmVyLFxufSBmcm9tICdlbnp5bWUtYWRhcHRlci11dGlscyc7XG5pbXBvcnQgeyBmaW5kQ3VycmVudEZpYmVyVXNpbmdTbG93UGF0aCB9IGZyb20gJ3JlYWN0LXJlY29uY2lsZXIvcmVmbGVjdGlvbic7XG5cbmNvbnN0IEhvc3RSb290ID0gMztcbmNvbnN0IENsYXNzQ29tcG9uZW50ID0gMjtcbmNvbnN0IEZyYWdtZW50VHlwZSA9IDEwO1xuY29uc3QgRnVuY3Rpb25hbENvbXBvbmVudCA9IDE7XG5jb25zdCBIb3N0UG9ydGFsID0gNDtcbmNvbnN0IEhvc3RDb21wb25lbnQgPSA1O1xuY29uc3QgSG9zdFRleHQgPSA2O1xuY29uc3QgTW9kZSA9IDExO1xuY29uc3QgQ29udGV4dENvbnN1bWVyVHlwZSA9IDEyO1xuY29uc3QgQ29udGV4dFByb3ZpZGVyVHlwZSA9IDEzO1xuY29uc3QgRm9yd2FyZFJlZlR5cGUgPSAxNDtcblxuZnVuY3Rpb24gbm9kZUFuZFNpYmxpbmdzQXJyYXkobm9kZVdpdGhTaWJsaW5nKSB7XG4gIGNvbnN0IGFycmF5ID0gW107XG4gIGxldCBub2RlID0gbm9kZVdpdGhTaWJsaW5nO1xuICB3aGlsZSAobm9kZSAhPSBudWxsKSB7XG4gICAgYXJyYXkucHVzaChub2RlKTtcbiAgICBub2RlID0gbm9kZS5zaWJsaW5nO1xuICB9XG4gIHJldHVybiBhcnJheTtcbn1cblxuZnVuY3Rpb24gZmxhdHRlbihhcnIpIHtcbiAgY29uc3QgcmVzdWx0ID0gW107XG4gIGNvbnN0IHN0YWNrID0gW3sgaTogMCwgYXJyYXk6IGFyciB9XTtcbiAgd2hpbGUgKHN0YWNrLmxlbmd0aCkge1xuICAgIGNvbnN0IG4gPSBzdGFjay5wb3AoKTtcbiAgICB3aGlsZSAobi5pIDwgbi5hcnJheS5sZW5ndGgpIHtcbiAgICAgIGNvbnN0IGVsID0gbi5hcnJheVtuLmldO1xuICAgICAgbi5pICs9IDE7XG4gICAgICBpZiAoQXJyYXkuaXNBcnJheShlbCkpIHtcbiAgICAgICAgc3RhY2sucHVzaChuKTtcbiAgICAgICAgc3RhY2sucHVzaCh7IGk6IDAsIGFycmF5OiBlbCB9KTtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgICByZXN1bHQucHVzaChlbCk7XG4gICAgfVxuICB9XG4gIHJldHVybiByZXN1bHQ7XG59XG5cbmZ1bmN0aW9uIG5vZGVUeXBlRnJvbVR5cGUodHlwZSkge1xuICBpZiAodHlwZSA9PT0gUG9ydGFsKSB7XG4gICAgcmV0dXJuICdwb3J0YWwnO1xuICB9XG5cbiAgcmV0dXJuIHV0aWxOb2RlVHlwZUZyb21UeXBlKHR5cGUpO1xufVxuXG5mdW5jdGlvbiBlbGVtZW50VG9UcmVlKGVsKSB7XG4gIGlmICghaXNQb3J0YWwoZWwpKSB7XG4gICAgcmV0dXJuIHV0aWxFbGVtZW50VG9UcmVlKGVsLCBlbGVtZW50VG9UcmVlKTtcbiAgfVxuXG4gIGNvbnN0IHsgY2hpbGRyZW4sIGNvbnRhaW5lckluZm8gfSA9IGVsO1xuICBjb25zdCBwcm9wcyA9IHsgY2hpbGRyZW4sIGNvbnRhaW5lckluZm8gfTtcblxuICByZXR1cm4ge1xuICAgIG5vZGVUeXBlOiAncG9ydGFsJyxcbiAgICB0eXBlOiBQb3J0YWwsXG4gICAgcHJvcHMsXG4gICAga2V5OiBlbnN1cmVLZXlPclVuZGVmaW5lZChlbC5rZXkpLFxuICAgIHJlZjogZWwucmVmIHx8IG51bGwsXG4gICAgaW5zdGFuY2U6IG51bGwsXG4gICAgcmVuZGVyZWQ6IGVsZW1lbnRUb1RyZWUoZWwuY2hpbGRyZW4pLFxuICB9O1xufVxuXG5mdW5jdGlvbiB0b1RyZWUodm5vZGUpIHtcbiAgaWYgKHZub2RlID09IG51bGwpIHtcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuICAvLyBUT0RPKGxtcik6IEknbSBub3QgcmVhbGx5IHN1cmUgSSB1bmRlcnN0YW5kIHdoZXRoZXIgb3Igbm90IHRoaXMgaXMgd2hhdFxuICAvLyBpIHNob3VsZCBiZSBkb2luZywgb3IgaWYgdGhpcyBpcyBhIGhhY2sgZm9yIHNvbWV0aGluZyBpJ20gZG9pbmcgd3JvbmdcbiAgLy8gc29tZXdoZXJlIGVsc2UuIFNob3VsZCB0YWxrIHRvIHNlYmFzdGlhbiBhYm91dCB0aGlzIHBlcmhhcHNcbiAgY29uc3Qgbm9kZSA9IGZpbmRDdXJyZW50RmliZXJVc2luZ1Nsb3dQYXRoKHZub2RlKTtcbiAgc3dpdGNoIChub2RlLnRhZykge1xuICAgIGNhc2UgSG9zdFJvb3Q6IC8vIDNcbiAgICAgIHJldHVybiBjaGlsZHJlblRvVHJlZShub2RlLmNoaWxkKTtcbiAgICBjYXNlIEhvc3RQb3J0YWw6IHsgLy8gNFxuICAgICAgY29uc3Qge1xuICAgICAgICBzdGF0ZU5vZGU6IHsgY29udGFpbmVySW5mbyB9LFxuICAgICAgICBtZW1vaXplZFByb3BzOiBjaGlsZHJlbixcbiAgICAgIH0gPSBub2RlO1xuICAgICAgY29uc3QgcHJvcHMgPSB7IGNvbnRhaW5lckluZm8sIGNoaWxkcmVuIH07XG4gICAgICByZXR1cm4ge1xuICAgICAgICBub2RlVHlwZTogJ3BvcnRhbCcsXG4gICAgICAgIHR5cGU6IFBvcnRhbCxcbiAgICAgICAgcHJvcHMsXG4gICAgICAgIGtleTogZW5zdXJlS2V5T3JVbmRlZmluZWQobm9kZS5rZXkpLFxuICAgICAgICByZWY6IG5vZGUucmVmLFxuICAgICAgICBpbnN0YW5jZTogbnVsbCxcbiAgICAgICAgcmVuZGVyZWQ6IGNoaWxkcmVuVG9UcmVlKG5vZGUuY2hpbGQpLFxuICAgICAgfTtcbiAgICB9XG4gICAgY2FzZSBDbGFzc0NvbXBvbmVudDpcbiAgICAgIHJldHVybiB7XG4gICAgICAgIG5vZGVUeXBlOiAnY2xhc3MnLFxuICAgICAgICB0eXBlOiBub2RlLnR5cGUsXG4gICAgICAgIHByb3BzOiB7IC4uLm5vZGUubWVtb2l6ZWRQcm9wcyB9LFxuICAgICAgICBrZXk6IGVuc3VyZUtleU9yVW5kZWZpbmVkKG5vZGUua2V5KSxcbiAgICAgICAgcmVmOiBub2RlLnJlZixcbiAgICAgICAgaW5zdGFuY2U6IG5vZGUuc3RhdGVOb2RlLFxuICAgICAgICByZW5kZXJlZDogY2hpbGRyZW5Ub1RyZWUobm9kZS5jaGlsZCksXG4gICAgICB9O1xuICAgIGNhc2UgRnVuY3Rpb25hbENvbXBvbmVudDogLy8gMVxuICAgICAgcmV0dXJuIHtcbiAgICAgICAgbm9kZVR5cGU6ICdmdW5jdGlvbicsXG4gICAgICAgIHR5cGU6IG5vZGUudHlwZSxcbiAgICAgICAgcHJvcHM6IHsgLi4ubm9kZS5tZW1vaXplZFByb3BzIH0sXG4gICAgICAgIGtleTogZW5zdXJlS2V5T3JVbmRlZmluZWQobm9kZS5rZXkpLFxuICAgICAgICByZWY6IG5vZGUucmVmLFxuICAgICAgICBpbnN0YW5jZTogbnVsbCxcbiAgICAgICAgcmVuZGVyZWQ6IGNoaWxkcmVuVG9UcmVlKG5vZGUuY2hpbGQpLFxuICAgICAgfTtcbiAgICBjYXNlIEhvc3RDb21wb25lbnQ6IHsgLy8gNVxuICAgICAgbGV0IHJlbmRlcmVkTm9kZXMgPSBmbGF0dGVuKG5vZGVBbmRTaWJsaW5nc0FycmF5KG5vZGUuY2hpbGQpLm1hcCh0b1RyZWUpKTtcbiAgICAgIGlmIChyZW5kZXJlZE5vZGVzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICByZW5kZXJlZE5vZGVzID0gW25vZGUubWVtb2l6ZWRQcm9wcy5jaGlsZHJlbl07XG4gICAgICB9XG4gICAgICByZXR1cm4ge1xuICAgICAgICBub2RlVHlwZTogJ2hvc3QnLFxuICAgICAgICB0eXBlOiBub2RlLnR5cGUsXG4gICAgICAgIHByb3BzOiB7IC4uLm5vZGUubWVtb2l6ZWRQcm9wcyB9LFxuICAgICAgICBrZXk6IGVuc3VyZUtleU9yVW5kZWZpbmVkKG5vZGUua2V5KSxcbiAgICAgICAgcmVmOiBub2RlLnJlZixcbiAgICAgICAgaW5zdGFuY2U6IG5vZGUuc3RhdGVOb2RlLFxuICAgICAgICByZW5kZXJlZDogcmVuZGVyZWROb2RlcyxcbiAgICAgIH07XG4gICAgfVxuICAgIGNhc2UgSG9zdFRleHQ6IC8vIDZcbiAgICAgIHJldHVybiBub2RlLm1lbW9pemVkUHJvcHM7XG4gICAgY2FzZSBGcmFnbWVudFR5cGU6IC8vIDEwXG4gICAgY2FzZSBNb2RlOiAvLyAxMVxuICAgIGNhc2UgQ29udGV4dFByb3ZpZGVyVHlwZTogLy8gMTNcbiAgICBjYXNlIENvbnRleHRDb25zdW1lclR5cGU6IC8vIDEyXG4gICAgICByZXR1cm4gY2hpbGRyZW5Ub1RyZWUobm9kZS5jaGlsZCk7XG4gICAgY2FzZSBGb3J3YXJkUmVmVHlwZToge1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgbm9kZVR5cGU6ICdmdW5jdGlvbicsXG4gICAgICAgIHR5cGU6IG5vZGUudHlwZSxcbiAgICAgICAgcHJvcHM6IHsgLi4ubm9kZS5wZW5kaW5nUHJvcHMgfSxcbiAgICAgICAga2V5OiBlbnN1cmVLZXlPclVuZGVmaW5lZChub2RlLmtleSksXG4gICAgICAgIHJlZjogbm9kZS5yZWYsXG4gICAgICAgIGluc3RhbmNlOiBudWxsLFxuICAgICAgICByZW5kZXJlZDogY2hpbGRyZW5Ub1RyZWUobm9kZS5jaGlsZCksXG4gICAgICB9O1xuICAgIH1cbiAgICBkZWZhdWx0OlxuICAgICAgdGhyb3cgbmV3IEVycm9yKGBFbnp5bWUgSW50ZXJuYWwgRXJyb3I6IHVua25vd24gbm9kZSB3aXRoIHRhZyAke25vZGUudGFnfWApO1xuICB9XG59XG5cbmZ1bmN0aW9uIGNoaWxkcmVuVG9UcmVlKG5vZGUpIHtcbiAgaWYgKCFub2RlKSB7XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cbiAgY29uc3QgY2hpbGRyZW4gPSBub2RlQW5kU2libGluZ3NBcnJheShub2RlKTtcbiAgaWYgKGNoaWxkcmVuLmxlbmd0aCA9PT0gMCkge1xuICAgIHJldHVybiBudWxsO1xuICB9XG4gIGlmIChjaGlsZHJlbi5sZW5ndGggPT09IDEpIHtcbiAgICByZXR1cm4gdG9UcmVlKGNoaWxkcmVuWzBdKTtcbiAgfVxuICByZXR1cm4gZmxhdHRlbihjaGlsZHJlbi5tYXAodG9UcmVlKSk7XG59XG5cbmZ1bmN0aW9uIG5vZGVUb0hvc3ROb2RlKF9ub2RlKSB7XG4gIC8vIE5PVEUobG1yKTogbm9kZSBjb3VsZCBiZSBhIGZ1bmN0aW9uIGNvbXBvbmVudFxuICAvLyB3aGljaCB3b250IGhhdmUgYW4gaW5zdGFuY2UgcHJvcCwgYnV0IHdlIGNhbiBnZXQgdGhlXG4gIC8vIGhvc3Qgbm9kZSBhc3NvY2lhdGVkIHdpdGggaXRzIHJldHVybiB2YWx1ZSBhdCB0aGF0IHBvaW50LlxuICAvLyBBbHRob3VnaCB0aGlzIGJyZWFrcyBkb3duIGlmIHRoZSByZXR1cm4gdmFsdWUgaXMgYW4gYXJyYXksXG4gIC8vIGFzIGlzIHBvc3NpYmxlIHdpdGggUmVhY3QgMTYuXG4gIGxldCBub2RlID0gX25vZGU7XG4gIHdoaWxlIChub2RlICYmICFBcnJheS5pc0FycmF5KG5vZGUpICYmIG5vZGUuaW5zdGFuY2UgPT09IG51bGwpIHtcbiAgICBub2RlID0gbm9kZS5yZW5kZXJlZDtcbiAgfVxuICAvLyBpZiB0aGUgU0ZDIHJldHVybmVkIG51bGwgZWZmZWN0aXZlbHksIHRoZXJlIGlzIG5vIGhvc3Qgbm9kZS5cbiAgaWYgKCFub2RlKSB7XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cblxuICBjb25zdCBtYXBwZXIgPSAoaXRlbSkgPT4ge1xuICAgIGlmIChpdGVtICYmIGl0ZW0uaW5zdGFuY2UpIHJldHVybiBSZWFjdERPTS5maW5kRE9NTm9kZShpdGVtLmluc3RhbmNlKTtcbiAgICByZXR1cm4gbnVsbDtcbiAgfTtcbiAgaWYgKEFycmF5LmlzQXJyYXkobm9kZSkpIHtcbiAgICByZXR1cm4gbm9kZS5tYXAobWFwcGVyKTtcbiAgfVxuICBpZiAoQXJyYXkuaXNBcnJheShub2RlLnJlbmRlcmVkKSAmJiBub2RlLm5vZGVUeXBlID09PSAnY2xhc3MnKSB7XG4gICAgcmV0dXJuIG5vZGUucmVuZGVyZWQubWFwKG1hcHBlcik7XG4gIH1cbiAgcmV0dXJuIG1hcHBlcihub2RlKTtcbn1cblxuZnVuY3Rpb24gZ2V0UHJvdmlkZXJEZWZhdWx0VmFsdWUoUHJvdmlkZXIpIHtcbiAgLy8gUmVhY3Qgc3RvcmVzIHJlZmVyZW5jZXMgdG8gdGhlIFByb3ZpZGVyJ3MgZGVmYXVsdFZhbHVlIGRpZmZlcmVudGx5IGFjcm9zcyB2ZXJzaW9ucy5cbiAgaWYgKCdfZGVmYXVsdFZhbHVlJyBpbiBQcm92aWRlci5fY29udGV4dCkge1xuICAgIHJldHVybiBQcm92aWRlci5fY29udGV4dC5fZGVmYXVsdFZhbHVlO1xuICB9XG4gIHRocm93IG5ldyBFcnJvcignRW56eW1lIEludGVybmFsIEVycm9yOiBjYW7igJl0IGZpZ3VyZSBvdXQgaG93IHRvIGdldCBQcm92aWRlcuKAmXMgZGVmYXVsdCB2YWx1ZScpO1xufVxuXG5mdW5jdGlvbiBtYWtlRmFrZUVsZW1lbnQodHlwZSkge1xuICByZXR1cm4geyAkJHR5cGVvZjogRWxlbWVudCwgdHlwZSB9O1xufVxuXG5jb25zdCBldmVudE9wdGlvbnMgPSB7IGFuaW1hdGlvbjogdHJ1ZSB9O1xuXG5jbGFzcyBSZWFjdFNpeHRlZW5UaHJlZUFkYXB0ZXIgZXh0ZW5kcyBFbnp5bWVBZGFwdGVyIHtcbiAgY29uc3RydWN0b3IoKSB7XG4gICAgc3VwZXIoKTtcbiAgICBjb25zdCB7IGxpZmVjeWNsZXMgfSA9IHRoaXMub3B0aW9ucztcbiAgICB0aGlzLm9wdGlvbnMgPSB7XG4gICAgICAuLi50aGlzLm9wdGlvbnMsXG4gICAgICBlbmFibGVDb21wb25lbnREaWRVcGRhdGVPblNldFN0YXRlOiB0cnVlLCAvLyBUT0RPOiByZW1vdmUsIHNlbXZlci1tYWpvclxuICAgICAgbGVnYWN5Q29udGV4dE1vZGU6ICdwYXJlbnQnLFxuICAgICAgbGlmZWN5Y2xlczoge1xuICAgICAgICAuLi5saWZlY3ljbGVzLFxuICAgICAgICBjb21wb25lbnREaWRVcGRhdGU6IHtcbiAgICAgICAgICBvblNldFN0YXRlOiB0cnVlLFxuICAgICAgICB9LFxuICAgICAgICBnZXREZXJpdmVkU3RhdGVGcm9tUHJvcHM6IHtcbiAgICAgICAgICBoYXNTaG91bGRDb21wb25lbnRVcGRhdGVCdWc6IHRydWUsXG4gICAgICAgIH0sXG4gICAgICAgIGdldFNuYXBzaG90QmVmb3JlVXBkYXRlOiB0cnVlLFxuICAgICAgICBzZXRTdGF0ZToge1xuICAgICAgICAgIHNraXBzQ29tcG9uZW50RGlkVXBkYXRlT25OdWxsaXNoOiB0cnVlLFxuICAgICAgICB9LFxuICAgICAgICBnZXRDaGlsZENvbnRleHQ6IHtcbiAgICAgICAgICBjYWxsZWRCeVJlbmRlcmVyOiBmYWxzZSxcbiAgICAgICAgfSxcbiAgICAgIH0sXG4gICAgfTtcbiAgfVxuXG4gIGNyZWF0ZU1vdW50UmVuZGVyZXIob3B0aW9ucykge1xuICAgIGFzc2VydERvbUF2YWlsYWJsZSgnbW91bnQnKTtcbiAgICBjb25zdCB7IGF0dGFjaFRvLCBoeWRyYXRlSW4sIHdyYXBwaW5nQ29tcG9uZW50UHJvcHMgfSA9IG9wdGlvbnM7XG4gICAgY29uc3QgZG9tTm9kZSA9IGh5ZHJhdGVJbiB8fCBhdHRhY2hUbyB8fCBnbG9iYWwuZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG4gICAgbGV0IGluc3RhbmNlID0gbnVsbDtcbiAgICBjb25zdCBhZGFwdGVyID0gdGhpcztcbiAgICByZXR1cm4ge1xuICAgICAgcmVuZGVyKGVsLCBjb250ZXh0LCBjYWxsYmFjaykge1xuICAgICAgICBpZiAoaW5zdGFuY2UgPT09IG51bGwpIHtcbiAgICAgICAgICBjb25zdCB7IHR5cGUsIHByb3BzLCByZWYgfSA9IGVsO1xuICAgICAgICAgIGNvbnN0IHdyYXBwZXJQcm9wcyA9IHtcbiAgICAgICAgICAgIENvbXBvbmVudDogdHlwZSxcbiAgICAgICAgICAgIHByb3BzLFxuICAgICAgICAgICAgd3JhcHBpbmdDb21wb25lbnRQcm9wcyxcbiAgICAgICAgICAgIGNvbnRleHQsXG4gICAgICAgICAgICAuLi4ocmVmICYmIHsgcmVmIH0pLFxuICAgICAgICAgIH07XG4gICAgICAgICAgY29uc3QgUmVhY3RXcmFwcGVyQ29tcG9uZW50ID0gY3JlYXRlTW91bnRXcmFwcGVyKGVsLCB7IC4uLm9wdGlvbnMsIGFkYXB0ZXIgfSk7XG4gICAgICAgICAgY29uc3Qgd3JhcHBlZEVsID0gUmVhY3QuY3JlYXRlRWxlbWVudChSZWFjdFdyYXBwZXJDb21wb25lbnQsIHdyYXBwZXJQcm9wcyk7XG4gICAgICAgICAgaW5zdGFuY2UgPSBoeWRyYXRlSW5cbiAgICAgICAgICAgID8gUmVhY3RET00uaHlkcmF0ZSh3cmFwcGVkRWwsIGRvbU5vZGUpXG4gICAgICAgICAgICA6IFJlYWN0RE9NLnJlbmRlcih3cmFwcGVkRWwsIGRvbU5vZGUpO1xuICAgICAgICAgIGlmICh0eXBlb2YgY2FsbGJhY2sgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgIGNhbGxiYWNrKCk7XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGluc3RhbmNlLnNldENoaWxkUHJvcHMoZWwucHJvcHMsIGNvbnRleHQsIGNhbGxiYWNrKTtcbiAgICAgICAgfVxuICAgICAgfSxcbiAgICAgIHVubW91bnQoKSB7XG4gICAgICAgIFJlYWN0RE9NLnVubW91bnRDb21wb25lbnRBdE5vZGUoZG9tTm9kZSk7XG4gICAgICAgIGluc3RhbmNlID0gbnVsbDtcbiAgICAgIH0sXG4gICAgICBnZXROb2RlKCkge1xuICAgICAgICBpZiAoIWluc3RhbmNlKSB7XG4gICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGdldE5vZGVGcm9tUm9vdEZpbmRlcihcbiAgICAgICAgICBhZGFwdGVyLmlzQ3VzdG9tQ29tcG9uZW50LFxuICAgICAgICAgIHRvVHJlZShpbnN0YW5jZS5fcmVhY3RJbnRlcm5hbEZpYmVyKSxcbiAgICAgICAgICBvcHRpb25zLFxuICAgICAgICApO1xuICAgICAgfSxcbiAgICAgIHNpbXVsYXRlRXJyb3Iobm9kZUhpZXJhcmNoeSwgcm9vdE5vZGUsIGVycm9yKSB7XG4gICAgICAgIGNvbnN0IHsgaW5zdGFuY2U6IGNhdGNoaW5nSW5zdGFuY2UgfSA9IG5vZGVIaWVyYXJjaHlcbiAgICAgICAgICAuZmluZCh4ID0+IHguaW5zdGFuY2UgJiYgeC5pbnN0YW5jZS5jb21wb25lbnREaWRDYXRjaCkgfHwge307XG5cbiAgICAgICAgc2ltdWxhdGVFcnJvcihcbiAgICAgICAgICBlcnJvcixcbiAgICAgICAgICBjYXRjaGluZ0luc3RhbmNlLFxuICAgICAgICAgIHJvb3ROb2RlLFxuICAgICAgICAgIG5vZGVIaWVyYXJjaHksXG4gICAgICAgICAgbm9kZVR5cGVGcm9tVHlwZSxcbiAgICAgICAgICBhZGFwdGVyLmRpc3BsYXlOYW1lT2ZOb2RlLFxuICAgICAgICApO1xuICAgICAgfSxcbiAgICAgIHNpbXVsYXRlRXZlbnQobm9kZSwgZXZlbnQsIG1vY2spIHtcbiAgICAgICAgY29uc3QgbWFwcGVkRXZlbnQgPSBtYXBOYXRpdmVFdmVudE5hbWVzKGV2ZW50LCBldmVudE9wdGlvbnMpO1xuICAgICAgICBjb25zdCBldmVudEZuID0gVGVzdFV0aWxzLlNpbXVsYXRlW21hcHBlZEV2ZW50XTtcbiAgICAgICAgaWYgKCFldmVudEZuKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihgUmVhY3RXcmFwcGVyOjpzaW11bGF0ZSgpIGV2ZW50ICcke2V2ZW50fScgZG9lcyBub3QgZXhpc3RgKTtcbiAgICAgICAgfVxuICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgcmVhY3Qvbm8tZmluZC1kb20tbm9kZVxuICAgICAgICBldmVudEZuKGFkYXB0ZXIubm9kZVRvSG9zdE5vZGUobm9kZSksIG1vY2spO1xuICAgICAgfSxcbiAgICAgIGJhdGNoZWRVcGRhdGVzKGZuKSB7XG4gICAgICAgIHJldHVybiBmbigpO1xuICAgICAgICAvLyByZXR1cm4gUmVhY3RET00udW5zdGFibGVfYmF0Y2hlZFVwZGF0ZXMoZm4pO1xuICAgICAgfSxcbiAgICAgIGdldFdyYXBwaW5nQ29tcG9uZW50UmVuZGVyZXIoKSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgLi4udGhpcyxcbiAgICAgICAgICAuLi5nZXRXcmFwcGluZ0NvbXBvbmVudE1vdW50UmVuZGVyZXIoe1xuICAgICAgICAgICAgdG9UcmVlOiBpbnN0ID0+IHRvVHJlZShpbnN0Ll9yZWFjdEludGVybmFsRmliZXIpLFxuICAgICAgICAgICAgZ2V0TW91bnRXcmFwcGVySW5zdGFuY2U6ICgpID0+IGluc3RhbmNlLFxuICAgICAgICAgIH0pLFxuICAgICAgICB9O1xuICAgICAgfSxcbiAgICB9O1xuICB9XG5cbiAgY3JlYXRlU2hhbGxvd1JlbmRlcmVyKC8qIG9wdGlvbnMgKi8pIHtcbiAgICBjb25zdCBhZGFwdGVyID0gdGhpcztcbiAgICBjb25zdCByZW5kZXJlciA9IG5ldyBTaGFsbG93UmVuZGVyZXIoKTtcbiAgICBsZXQgaXNET00gPSBmYWxzZTtcbiAgICBsZXQgY2FjaGVkTm9kZSA9IG51bGw7XG4gICAgcmV0dXJuIHtcbiAgICAgIHJlbmRlcihlbCwgY29udGV4dCwge1xuICAgICAgICBwcm92aWRlclZhbHVlcyA9IG5ldyBNYXAoKSxcbiAgICAgIH0gPSB7fSkge1xuICAgICAgICBjYWNoZWROb2RlID0gZWw7XG4gICAgICAgIC8qIGVzbGludCBjb25zaXN0ZW50LXJldHVybjogMCAqL1xuICAgICAgICBpZiAodHlwZW9mIGVsLnR5cGUgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgaXNET00gPSB0cnVlO1xuICAgICAgICB9IGVsc2UgaWYgKGlzQ29udGV4dFByb3ZpZGVyKGVsKSkge1xuICAgICAgICAgIHByb3ZpZGVyVmFsdWVzLnNldChlbC50eXBlLCBlbC5wcm9wcy52YWx1ZSk7XG4gICAgICAgICAgY29uc3QgTW9ja1Byb3ZpZGVyID0gT2JqZWN0LmFzc2lnbihcbiAgICAgICAgICAgIHByb3BzID0+IHByb3BzLmNoaWxkcmVuLFxuICAgICAgICAgICAgZWwudHlwZSxcbiAgICAgICAgICApO1xuICAgICAgICAgIHJldHVybiB3aXRoU2V0U3RhdGVBbGxvd2VkKCgpID0+IHJlbmRlcmVyLnJlbmRlcih7IC4uLmVsLCB0eXBlOiBNb2NrUHJvdmlkZXIgfSkpO1xuICAgICAgICB9IGVsc2UgaWYgKGlzQ29udGV4dENvbnN1bWVyKGVsKSkge1xuICAgICAgICAgIGNvbnN0IFByb3ZpZGVyID0gYWRhcHRlci5nZXRQcm92aWRlckZyb21Db25zdW1lcihlbC50eXBlKTtcbiAgICAgICAgICBjb25zdCB2YWx1ZSA9IHByb3ZpZGVyVmFsdWVzLmhhcyhQcm92aWRlcilcbiAgICAgICAgICAgID8gcHJvdmlkZXJWYWx1ZXMuZ2V0KFByb3ZpZGVyKVxuICAgICAgICAgICAgOiBnZXRQcm92aWRlckRlZmF1bHRWYWx1ZShQcm92aWRlcik7XG4gICAgICAgICAgY29uc3QgTW9ja0NvbnN1bWVyID0gT2JqZWN0LmFzc2lnbihcbiAgICAgICAgICAgIHByb3BzID0+IHByb3BzLmNoaWxkcmVuKHZhbHVlKSxcbiAgICAgICAgICAgIGVsLnR5cGUsXG4gICAgICAgICAgKTtcbiAgICAgICAgICByZXR1cm4gd2l0aFNldFN0YXRlQWxsb3dlZCgoKSA9PiByZW5kZXJlci5yZW5kZXIoeyAuLi5lbCwgdHlwZTogTW9ja0NvbnN1bWVyIH0pKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBpc0RPTSA9IGZhbHNlO1xuICAgICAgICAgIGNvbnN0IHsgdHlwZTogQ29tcG9uZW50IH0gPSBlbDtcblxuICAgICAgICAgIGNvbnN0IGlzU3RhdGVmdWwgPSBDb21wb25lbnQucHJvdG90eXBlICYmIChcbiAgICAgICAgICAgIENvbXBvbmVudC5wcm90b3R5cGUuaXNSZWFjdENvbXBvbmVudFxuICAgICAgICAgICAgfHwgQXJyYXkuaXNBcnJheShDb21wb25lbnQuX19yZWFjdEF1dG9CaW5kUGFpcnMpIC8vIGZhbGxiYWNrIGZvciBjcmVhdGVDbGFzcyBjb21wb25lbnRzXG4gICAgICAgICAgKTtcblxuICAgICAgICAgIGlmICghaXNTdGF0ZWZ1bCAmJiB0eXBlb2YgQ29tcG9uZW50ID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICBjb25zdCB3cmFwcGVkRWwgPSBPYmplY3QuYXNzaWduKFxuICAgICAgICAgICAgICAoLi4uYXJncykgPT4gQ29tcG9uZW50KC4uLmFyZ3MpLCAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIG5ldy1jYXBcbiAgICAgICAgICAgICAgQ29tcG9uZW50LFxuICAgICAgICAgICAgKTtcbiAgICAgICAgICAgIHJldHVybiB3aXRoU2V0U3RhdGVBbGxvd2VkKCgpID0+IHJlbmRlcmVyLnJlbmRlcih7IC4uLmVsLCB0eXBlOiB3cmFwcGVkRWwgfSwgY29udGV4dCkpO1xuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm4gd2l0aFNldFN0YXRlQWxsb3dlZCgoKSA9PiByZW5kZXJlci5yZW5kZXIoZWwsIGNvbnRleHQpKTtcbiAgICAgICAgfVxuICAgICAgfSxcbiAgICAgIHVubW91bnQoKSB7XG4gICAgICAgIHJlbmRlcmVyLnVubW91bnQoKTtcbiAgICAgIH0sXG4gICAgICBnZXROb2RlKCkge1xuICAgICAgICBpZiAoaXNET00pIHtcbiAgICAgICAgICByZXR1cm4gZWxlbWVudFRvVHJlZShjYWNoZWROb2RlKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBvdXRwdXQgPSByZW5kZXJlci5nZXRSZW5kZXJPdXRwdXQoKTtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICBub2RlVHlwZTogbm9kZVR5cGVGcm9tVHlwZShjYWNoZWROb2RlLnR5cGUpLFxuICAgICAgICAgIHR5cGU6IGNhY2hlZE5vZGUudHlwZSxcbiAgICAgICAgICBwcm9wczogY2FjaGVkTm9kZS5wcm9wcyxcbiAgICAgICAgICBrZXk6IGVuc3VyZUtleU9yVW5kZWZpbmVkKGNhY2hlZE5vZGUua2V5KSxcbiAgICAgICAgICByZWY6IGNhY2hlZE5vZGUucmVmLFxuICAgICAgICAgIGluc3RhbmNlOiByZW5kZXJlci5faW5zdGFuY2UsXG4gICAgICAgICAgcmVuZGVyZWQ6IEFycmF5LmlzQXJyYXkob3V0cHV0KVxuICAgICAgICAgICAgPyBmbGF0dGVuKG91dHB1dCkubWFwKGVsID0+IGVsZW1lbnRUb1RyZWUoZWwpKVxuICAgICAgICAgICAgOiBlbGVtZW50VG9UcmVlKG91dHB1dCksXG4gICAgICAgIH07XG4gICAgICB9LFxuICAgICAgc2ltdWxhdGVFcnJvcihub2RlSGllcmFyY2h5LCByb290Tm9kZSwgZXJyb3IpIHtcbiAgICAgICAgc2ltdWxhdGVFcnJvcihcbiAgICAgICAgICBlcnJvcixcbiAgICAgICAgICByZW5kZXJlci5faW5zdGFuY2UsXG4gICAgICAgICAgY2FjaGVkTm9kZSxcbiAgICAgICAgICBub2RlSGllcmFyY2h5LmNvbmNhdChjYWNoZWROb2RlKSxcbiAgICAgICAgICBub2RlVHlwZUZyb21UeXBlLFxuICAgICAgICAgIGFkYXB0ZXIuZGlzcGxheU5hbWVPZk5vZGUsXG4gICAgICAgICk7XG4gICAgICB9LFxuICAgICAgc2ltdWxhdGVFdmVudChub2RlLCBldmVudCwgLi4uYXJncykge1xuICAgICAgICBjb25zdCBoYW5kbGVyID0gbm9kZS5wcm9wc1twcm9wRnJvbUV2ZW50KGV2ZW50LCBldmVudE9wdGlvbnMpXTtcbiAgICAgICAgaWYgKGhhbmRsZXIpIHtcbiAgICAgICAgICB3aXRoU2V0U3RhdGVBbGxvd2VkKCgpID0+IHtcbiAgICAgICAgICAgIC8vIFRPRE8obG1yKTogY3JlYXRlL3VzZSBzeW50aGV0aWMgZXZlbnRzXG4gICAgICAgICAgICAvLyBUT0RPKGxtcik6IGVtdWxhdGUgUmVhY3QncyBldmVudCBwcm9wYWdhdGlvblxuICAgICAgICAgICAgLy8gUmVhY3RET00udW5zdGFibGVfYmF0Y2hlZFVwZGF0ZXMoKCkgPT4ge1xuICAgICAgICAgICAgaGFuZGxlciguLi5hcmdzKTtcbiAgICAgICAgICAgIC8vIH0pO1xuICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICB9LFxuICAgICAgYmF0Y2hlZFVwZGF0ZXMoZm4pIHtcbiAgICAgICAgcmV0dXJuIGZuKCk7XG4gICAgICAgIC8vIHJldHVybiBSZWFjdERPTS51bnN0YWJsZV9iYXRjaGVkVXBkYXRlcyhmbik7XG4gICAgICB9LFxuICAgICAgY2hlY2tQcm9wVHlwZXModHlwZVNwZWNzLCB2YWx1ZXMsIGxvY2F0aW9uLCBoaWVyYXJjaHkpIHtcbiAgICAgICAgcmV0dXJuIGNoZWNrUHJvcFR5cGVzKFxuICAgICAgICAgIHR5cGVTcGVjcyxcbiAgICAgICAgICB2YWx1ZXMsXG4gICAgICAgICAgbG9jYXRpb24sXG4gICAgICAgICAgZGlzcGxheU5hbWVPZk5vZGUoY2FjaGVkTm9kZSksXG4gICAgICAgICAgKCkgPT4gZ2V0Q29tcG9uZW50U3RhY2soaGllcmFyY2h5LmNvbmNhdChbY2FjaGVkTm9kZV0pKSxcbiAgICAgICAgKTtcbiAgICAgIH0sXG4gICAgfTtcbiAgfVxuXG4gIGNyZWF0ZVN0cmluZ1JlbmRlcmVyKG9wdGlvbnMpIHtcbiAgICByZXR1cm4ge1xuICAgICAgcmVuZGVyKGVsLCBjb250ZXh0KSB7XG4gICAgICAgIGlmIChvcHRpb25zLmNvbnRleHQgJiYgKGVsLnR5cGUuY29udGV4dFR5cGVzIHx8IG9wdGlvbnMuY2hpbGRDb250ZXh0VHlwZXMpKSB7XG4gICAgICAgICAgY29uc3QgY2hpbGRDb250ZXh0VHlwZXMgPSB7XG4gICAgICAgICAgICAuLi4oZWwudHlwZS5jb250ZXh0VHlwZXMgfHwge30pLFxuICAgICAgICAgICAgLi4ub3B0aW9ucy5jaGlsZENvbnRleHRUeXBlcyxcbiAgICAgICAgICB9O1xuICAgICAgICAgIGNvbnN0IENvbnRleHRXcmFwcGVyID0gY3JlYXRlUmVuZGVyV3JhcHBlcihlbCwgY29udGV4dCwgY2hpbGRDb250ZXh0VHlwZXMpO1xuICAgICAgICAgIHJldHVybiBSZWFjdERPTVNlcnZlci5yZW5kZXJUb1N0YXRpY01hcmt1cChSZWFjdC5jcmVhdGVFbGVtZW50KENvbnRleHRXcmFwcGVyKSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIFJlYWN0RE9NU2VydmVyLnJlbmRlclRvU3RhdGljTWFya3VwKGVsKTtcbiAgICAgIH0sXG4gICAgfTtcbiAgfVxuXG4gIC8vIFByb3ZpZGVkIGEgYmFnIG9mIG9wdGlvbnMsIHJldHVybiBhbiBgRW56eW1lUmVuZGVyZXJgLiBTb21lIG9wdGlvbnMgY2FuIGJlIGltcGxlbWVudGF0aW9uXG4gIC8vIHNwZWNpZmljLCBsaWtlIGBhdHRhY2hgIGV0Yy4gZm9yIFJlYWN0LCBidXQgbm90IHBhcnQgb2YgdGhpcyBpbnRlcmZhY2UgZXhwbGljaXRseS5cbiAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIGNsYXNzLW1ldGhvZHMtdXNlLXRoaXMsIG5vLXVudXNlZC12YXJzXG4gIGNyZWF0ZVJlbmRlcmVyKG9wdGlvbnMpIHtcbiAgICBzd2l0Y2ggKG9wdGlvbnMubW9kZSkge1xuICAgICAgY2FzZSBFbnp5bWVBZGFwdGVyLk1PREVTLk1PVU5UOiByZXR1cm4gdGhpcy5jcmVhdGVNb3VudFJlbmRlcmVyKG9wdGlvbnMpO1xuICAgICAgY2FzZSBFbnp5bWVBZGFwdGVyLk1PREVTLlNIQUxMT1c6IHJldHVybiB0aGlzLmNyZWF0ZVNoYWxsb3dSZW5kZXJlcihvcHRpb25zKTtcbiAgICAgIGNhc2UgRW56eW1lQWRhcHRlci5NT0RFUy5TVFJJTkc6IHJldHVybiB0aGlzLmNyZWF0ZVN0cmluZ1JlbmRlcmVyKG9wdGlvbnMpO1xuICAgICAgZGVmYXVsdDpcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBFbnp5bWUgSW50ZXJuYWwgRXJyb3I6IFVucmVjb2duaXplZCBtb2RlOiAke29wdGlvbnMubW9kZX1gKTtcbiAgICB9XG4gIH1cblxuICB3cmFwKGVsZW1lbnQpIHtcbiAgICByZXR1cm4gd3JhcChlbGVtZW50KTtcbiAgfVxuXG4gIC8vIGNvbnZlcnRzIGFuIFJTVE5vZGUgdG8gdGhlIGNvcnJlc3BvbmRpbmcgSlNYIFByYWdtYSBFbGVtZW50LiBUaGlzIHdpbGwgYmUgbmVlZGVkXG4gIC8vIGluIG9yZGVyIHRvIGltcGxlbWVudCB0aGUgYFdyYXBwZXIubW91bnQoKWAgYW5kIGBXcmFwcGVyLnNoYWxsb3coKWAgbWV0aG9kcywgYnV0IHNob3VsZFxuICAvLyBiZSBwcmV0dHkgc3RyYWlnaHRmb3J3YXJkIGZvciBwZW9wbGUgdG8gaW1wbGVtZW50LlxuICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgY2xhc3MtbWV0aG9kcy11c2UtdGhpcywgbm8tdW51c2VkLXZhcnNcbiAgbm9kZVRvRWxlbWVudChub2RlKSB7XG4gICAgaWYgKCFub2RlIHx8IHR5cGVvZiBub2RlICE9PSAnb2JqZWN0JykgcmV0dXJuIG51bGw7XG4gICAgcmV0dXJuIFJlYWN0LmNyZWF0ZUVsZW1lbnQobm9kZS50eXBlLCBwcm9wc1dpdGhLZXlzQW5kUmVmKG5vZGUpKTtcbiAgfVxuXG4gIGVsZW1lbnRUb05vZGUoZWxlbWVudCkge1xuICAgIHJldHVybiBlbGVtZW50VG9UcmVlKGVsZW1lbnQpO1xuICB9XG5cbiAgbm9kZVRvSG9zdE5vZGUobm9kZSwgc3VwcG9ydHNBcnJheSA9IGZhbHNlKSB7XG4gICAgY29uc3Qgbm9kZXMgPSBub2RlVG9Ib3N0Tm9kZShub2RlKTtcbiAgICBpZiAoQXJyYXkuaXNBcnJheShub2RlcykgJiYgIXN1cHBvcnRzQXJyYXkpIHtcbiAgICAgIHJldHVybiBub2Rlc1swXTtcbiAgICB9XG4gICAgcmV0dXJuIG5vZGVzO1xuICB9XG5cbiAgZGlzcGxheU5hbWVPZk5vZGUobm9kZSkge1xuICAgIGlmICghbm9kZSkgcmV0dXJuIG51bGw7XG4gICAgY29uc3QgeyB0eXBlLCAkJHR5cGVvZiB9ID0gbm9kZTtcblxuICAgIGNvbnN0IG5vZGVUeXBlID0gdHlwZSB8fCAkJHR5cGVvZjtcblxuICAgIC8vIG5ld2VyIG5vZGUgdHlwZXMgbWF5IGJlIHVuZGVmaW5lZCwgc28gb25seSB0ZXN0IGlmIHRoZSBub2RlVHlwZSBleGlzdHNcbiAgICBpZiAobm9kZVR5cGUpIHtcbiAgICAgIHN3aXRjaCAobm9kZVR5cGUpIHtcbiAgICAgICAgY2FzZSBBc3luY01vZGUgfHwgTmFOOiByZXR1cm4gJ0FzeW5jTW9kZSc7XG4gICAgICAgIGNhc2UgRnJhZ21lbnQgfHwgTmFOOiByZXR1cm4gJ0ZyYWdtZW50JztcbiAgICAgICAgY2FzZSBTdHJpY3RNb2RlIHx8IE5hTjogcmV0dXJuICdTdHJpY3RNb2RlJztcbiAgICAgICAgY2FzZSBQb3J0YWwgfHwgTmFOOiByZXR1cm4gJ1BvcnRhbCc7XG4gICAgICAgIGRlZmF1bHQ6XG4gICAgICB9XG4gICAgfVxuXG4gICAgY29uc3QgJCR0eXBlb2ZUeXBlID0gdHlwZSAmJiB0eXBlLiQkdHlwZW9mO1xuXG4gICAgc3dpdGNoICgkJHR5cGVvZlR5cGUpIHtcbiAgICAgIGNhc2UgQ29udGV4dENvbnN1bWVyIHx8IE5hTjogcmV0dXJuICdDb250ZXh0Q29uc3VtZXInO1xuICAgICAgY2FzZSBDb250ZXh0UHJvdmlkZXIgfHwgTmFOOiByZXR1cm4gJ0NvbnRleHRQcm92aWRlcic7XG4gICAgICBjYXNlIEZvcndhcmRSZWYgfHwgTmFOOiB7XG4gICAgICAgIGlmICh0eXBlLmRpc3BsYXlOYW1lKSB7XG4gICAgICAgICAgcmV0dXJuIHR5cGUuZGlzcGxheU5hbWU7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgbmFtZSA9IGRpc3BsYXlOYW1lT2ZOb2RlKHsgdHlwZTogdHlwZS5yZW5kZXIgfSk7XG4gICAgICAgIHJldHVybiBuYW1lID8gYEZvcndhcmRSZWYoJHtuYW1lfSlgIDogJ0ZvcndhcmRSZWYnO1xuICAgICAgfVxuICAgICAgZGVmYXVsdDogcmV0dXJuIGRpc3BsYXlOYW1lT2ZOb2RlKG5vZGUpO1xuICAgIH1cbiAgfVxuXG4gIGlzVmFsaWRFbGVtZW50KGVsZW1lbnQpIHtcbiAgICByZXR1cm4gaXNFbGVtZW50KGVsZW1lbnQpO1xuICB9XG5cbiAgaXNWYWxpZEVsZW1lbnRUeXBlKG9iamVjdCkge1xuICAgIHJldHVybiAhIW9iamVjdCAmJiBpc1ZhbGlkRWxlbWVudFR5cGUob2JqZWN0KTtcbiAgfVxuXG4gIGlzRnJhZ21lbnQoZnJhZ21lbnQpIHtcbiAgICByZXR1cm4gdHlwZU9mTm9kZShmcmFnbWVudCkgPT09IEZyYWdtZW50O1xuICB9XG5cbiAgaXNDdXN0b21Db21wb25lbnQodHlwZSkge1xuICAgIGNvbnN0IGZha2VFbGVtZW50ID0gbWFrZUZha2VFbGVtZW50KHR5cGUpO1xuICAgIHJldHVybiAhIXR5cGUgJiYgKFxuICAgICAgdHlwZW9mIHR5cGUgPT09ICdmdW5jdGlvbidcbiAgICAgIHx8IGlzRm9yd2FyZFJlZihmYWtlRWxlbWVudClcbiAgICAgIHx8IGlzQ29udGV4dFByb3ZpZGVyKGZha2VFbGVtZW50KVxuICAgICAgfHwgaXNDb250ZXh0Q29uc3VtZXIoZmFrZUVsZW1lbnQpXG4gICAgKTtcbiAgfVxuXG4gIGlzQ29udGV4dENvbnN1bWVyKHR5cGUpIHtcbiAgICByZXR1cm4gISF0eXBlICYmIGlzQ29udGV4dENvbnN1bWVyKG1ha2VGYWtlRWxlbWVudCh0eXBlKSk7XG4gIH1cblxuICBpc0N1c3RvbUNvbXBvbmVudEVsZW1lbnQoaW5zdCkge1xuICAgIGlmICghaW5zdCB8fCAhdGhpcy5pc1ZhbGlkRWxlbWVudChpbnN0KSkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcy5pc0N1c3RvbUNvbXBvbmVudChpbnN0LnR5cGUpO1xuICB9XG5cbiAgZ2V0UHJvdmlkZXJGcm9tQ29uc3VtZXIoQ29uc3VtZXIpIHtcbiAgICBjb25zdCB7IFByb3ZpZGVyIH0gPSBDb25zdW1lciB8fCB7fTtcbiAgICBpZiAoUHJvdmlkZXIpIHtcbiAgICAgIHJldHVybiBQcm92aWRlcjtcbiAgICB9XG4gICAgdGhyb3cgbmV3IEVycm9yKCdFbnp5bWUgSW50ZXJuYWwgRXJyb3I6IGNhbuKAmXQgZmlndXJlIG91dCBob3cgdG8gZ2V0IFByb3ZpZGVyIGZyb20gQ29uc3VtZXInKTtcbiAgfVxuXG4gIGNyZWF0ZUVsZW1lbnQoLi4uYXJncykge1xuICAgIHJldHVybiBSZWFjdC5jcmVhdGVFbGVtZW50KC4uLmFyZ3MpO1xuICB9XG5cbiAgd3JhcFdpdGhXcmFwcGluZ0NvbXBvbmVudChub2RlLCBvcHRpb25zKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIFJvb3RGaW5kZXIsXG4gICAgICBub2RlOiB3cmFwV2l0aFdyYXBwaW5nQ29tcG9uZW50KFJlYWN0LmNyZWF0ZUVsZW1lbnQsIG5vZGUsIG9wdGlvbnMpLFxuICAgIH07XG4gIH1cbn1cblxubW9kdWxlLmV4cG9ydHMgPSBSZWFjdFNpeHRlZW5UaHJlZUFkYXB0ZXI7XG4iXX0=
//# sourceMappingURL=ReactSixteenThreeAdapter.js.map